# 上市公司关联性RAG项目 - 棕地项目需求文档 (PRD)

* **版本**: 1.2
* **日期**: 2025年7月5日
* **作者**: Mary (Business Analyst), John (Product Manager)

## 1. 项目目标与背景

### 1.1 目标

* **核心目标**: 构建一个多功能的、针对A股上市公司的私有化RAG系统。
* **功能目标**:
    1.  **事实问答**：支持对单一公司的具体业务进行直接提问和回答。
    2.  **关联发现**：支持寻找与目标公司业务相关的其他公司。
* **技术目标**: 解决图谱构建不完整的问题，并引入向量数据库优化索引和查询性能。

### 1.2 背景

本项目是在一个已有的、基于`hipporag`的中文适配原型基础上进行的“棕地”开发。原型已包含中文Prompt模板和成熟的模型交互脚本，但在核心的图谱构建和索引流程上存在障碍，导致图谱信息不完整，影响最终QA效果。本次重新开发旨在梳理并固化该核心流程，使其更加健壮和高效。

## 2. 功能性需求 (Functional Requirements)

### 数据处理与索引流程

* **FR1: 文档处理与分块**
    * 系统必须能够读取 `corpus.json` 格式的文档列表。
    * 根据 `chinese_text_splitter.py` 中的策略，每个文档的完整 `text` 字段应被视为一个独立的、无需切分的文本块（Chunk）。

* **FR2: 命名实体识别 (NER)**
    * 对于每一个文本块，系统应调用大语言模型（LLM），使用 `ner_chinese.py` 中定义的Prompt模板来提取所有的命名实体。

* **FR3: 关系抽取 (RE)**
    * 对于每一个文本块及其对应的已提取命名实体列表（FR2的输出），系统应调用LLM，使用 `triple_extraction_chinese.py` 中定义的Prompt模板来抽取出所有的关系三元组。

* **FR4: 统一知识图谱构建**
    * 系统必须能将从所有文档中抽取出的三元组（FR3的输出）聚合起来，构建一个单一的、全局的知识图谱。
    * 图谱构建过程中需要进行实体去重和关系合并。

* **FR5: 文本嵌入 (Text Embedding)**
    * 系统应使用 `basic_embedding_advanced.py` 脚本中的 `Qwen3EmbeddingManager`，对所有从FR1中产生的文本块进行向量化，生成嵌入向量。

* **FR6: 向量化索引 (Vector Indexing)**
    * 系统需将FR5生成的嵌入向量及其元数据存入一个向量数据库中。
    * 元数据至少应包括：对应的公司名称 (`title`)、原始索引 (`idx`)、以及文本块内容本身。

### 问答（QA）流程

* **FR7: 查询意图识别 (Query Intent Detection)**
    * 系统必须首先对用户的查询进行意图分析，判断其属于“事实问答”还是“关联性发现”。
    * a. 若查询包含“相似”、“关联”、“类似”、“竞品”、“上下游”等词语，则判定为“**关联性发现**”。
    * b. 否则，默认判定为“**事实问答**”。
    * c. 对于包含两种意图的模糊查询，系统应优先执行“**事实问答**”，并在返回结果中提示用户可以进行“关联性发现”。

---
#### ► 分支 A：如果意图为“事实问答”

* **FR-A1: 向量检索 (Vector Retrieval)**
    * 系统根据问题中的公司实体，在向量数据库中检索最相关的文本块。
* **FR-A2: 结果重排序 (Reranking)**
    * 系统使用 `qwen3_reranker_official_best_practice.py` 的逻辑对检索结果进行相关性重排序。
* **FR-A3: 摘要回答与溯源**
    * 系统将重排后的文本块交给LLM，并要求LLM根据这些内容，直接总结回答用户的问题。
    * 答案必须附带来源文本块作为出处。

---
#### ► 分支 B：如果意图为“关联性发现”

* **FR-B1: 混合检索 (Hybrid Retrieval)**
    * 系统执行向量检索和图谱检索的混合策略。
* **FR-B2: 结果重排序 (Reranking)**
    * 系统使用 `qwen3_reranker_official_best_practice.py` 的逻辑进行重排序。
* **FR-B3: 事实过滤 (Fact Filtering)**
    * 系统使用 `filter_deepseek-chat-instruct.json` 的逻辑进行事实过滤。
* **FR-B4: 结构化答案生成与溯源**
    * 系统使用 `rag_qa_chinse_companies.py` 的逻辑生成结构化的关联公司答案。
    * 最终输出的结构化答案中，除了包含一个0到1之间、用于排序的数字“相似度分数”外，**必须**额外包含一个`relevance_level`（相关性等级）字段。该字段的值应为 `NFR2` 中定义的三个等级之一。

---
* **FR12 (异常处理)**
    * a. 当查询的公司在我们的数据集中不存在时，系统应返回明确的“公司未找到”提示。
    * b. 当“关联性发现”没有找到任何符合条件的公司时，系统应返回“未找到相关公司”的提示。

## 3. 非功能性需求 (Non-Functional Requirements)

* **NFR1 (性能 - Performance):**
    * 系统的设计应优先保证**答案的准确性和相关性**，其次才是响应速度。系统应尽可能返回所有高度相关的公司，而不应为了速度牺牲结果的全面性。

* **NFR2 (准确性与相关性 - Accuracy & Relevance):**
    * 系统定义“相关性”时，必须遵循以下优先级层次：
        1.  **最高优先级**：在**细分业务**上直接生产竞争产品的公司。
        2.  **中优先级**：生产相似或可替代产品的公司。
        3.  **低优先级**：处于产业链上下游关系的公司。
    * 系统的相似度分析必须具备**业务分类的深度感知能力**，能够深入到具体的、细分的业务层面进行比较。

* **NFR3 (可维护性 - Maintainability):**
    * **a. 增量更新与新增**：当数据发生变化或有新公司加入时，系统必须支持**增量索引**。
    * **b. 精确删除**：系统必须提供一个机制，能够根据唯一标识符**精确地删除**该公司所有相关的索引数据。

## 4. 史诗（Epics）规划与迭代策略

### 4.1 核心Epics

* **Epic 1: 基础数据管道与索引构建 (Foundational Data Pipeline & Indexing)**
    * **目标**: 完成一个健壮、完整、可供查询的公司知识图谱和向量索引，为上层应用提供坚实的数据基础。
    * **关联需求**: FR1 - FR6。

* **Epic 2: 核心问答与关联公司查询 MVP (Core Q&A and Related Company Search MVP)**
    * **目标**: 实现第一个可用的端到端查询功能，支持“事实问答”和“关联性发现”两种模式。
    * **关联需求**: FR7 - FR12。

### 4.2 迭代与演进策略 (Iteration & Evolution Strategy)

* **IES1 (迭代策略-意图识别):**
    * 系统的意图识别模块（FR7）必须包含一个**评估与验证环节**。在系统上线初期，对于低置信度的意图判断，应设计**回退或澄清机制**，以收集用户反馈，持续优化意图识别模型的准确性。

* **IES2 (迭代策略-相关性评分):**
    * 系统的“相关性评分模型”（涉及FR-B1至FR-B4）应被视为一个需要**持续迭代和微调的核心模块**。系统必须记录用户查询和最终采纳的结果，为后续的模型优化提供数据支持。架构设计应支持该模块的独立更新和A/B测试。

## 5. 潜在风险与缓解

* **风险-LLM可靠性**: LLM的输出存在不确定性，可能导致意图识别错误或图谱质量波动。
    * **缓解策略**: 见`IES1`，通过评估、验证和澄清机制来管理此风险。
* **风险-相关性量化**: 将业务逻辑精确转化为可信赖的“相似度分数”存在挑战。
    * **缓解策略**: 见`IES2`，将评分模型视为一个长期迭代的模块。
* **风险-数据维护**: 增量更新的复杂性可能破坏数据一致性。
    * **缓解策略**: 架构设计阶段必须将**可维护性**作为核心指标，并设计相应的测试用例。
* **风险-成本与性能**: 多步LLM调用可能导致成本或时间超预期。
    * **缓解策略**: 架构设计时需进行成本预估，并优先优化调用链路中最耗时或最昂贵的环节。

## 6. 后续步骤

* **架构设计**: 将此PRD交付给架构师（Winston），以设计满足所有功能性和非功能性需求的技术实现方案。
* **开发执行**: 架构设计完成后，将分解为具体的开发任务，并由开发代理按Epic顺序执行。